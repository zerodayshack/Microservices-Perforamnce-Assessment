---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*.
```{r}
#Script to plot TrainTicket results
#Version:  October 30th 2022
#Requires computeThreshold_train.R; computeDM_FUNCTIONS.R

#LIBRARIES
#Pre-requisites, comment these lines if you already installed the libraries# install.packages("RColorBrewer", repos = "http://cran.us.r-project.org")
# install.packages("gridExtra", repos = "http://cran.us.r-project.org")
# install.packages("gridBase",repos = "http://cran.us.r-project.org")
# install.packages("ggplot2",repos = "http://cran.us.r-project.org")
# install.packages("imager",repos = "http://cran.us.r-project.org")

library(ggplot2)
library(gridExtra)
library(gridExtra)
library(gridBase)
library(grid)
library(scales)
library(imager)
library(RColorBrewer)
library(readxl)
library(stringr)
library(grid)
library(ggplotify)


#The directory where the scripts are
scriptDirectory <- paste(getwd(), "/RScripts/", sep = "")

#Set folder for data and results. Substitute it with yours or comment it if you launch from terminal
dataDirectory <- paste(getwd(), "/DATA/TrainTicket/", sep = "")
setwd(dataDirectory)

#search for the name of the data files
files <- list.files(dataDirectory, pattern = ".xlsx", recursive = TRUE)


#Automatically detect from the file names the path for balance/unbalance iter1/iter2 experiemnts
pathData <- paste(dataDirectory, "TrainTicket_results.xlsx", sep = "")

#############
#CREATE POLYGONS
p2List <- list()
polygonList <- list()

#from the path name of the data file, create the path name of the file where to save failing services
strRem <- str_remove(pathData, ".xlsx")
# strRem <- pathData[:-5]
strRem <- tail(strsplit(strRem, "/")[[1]], 1)

#Create one dataset per type of deployment architecture mono/cqrs/role by reading the sheet with the corresponding name
sheets <- excel_sheets(pathData)
dddDataset <- as.data.frame(read_excel(pathData, sheet = "ddd"))
addDataset <- as.data.frame(read_excel(pathData, sheet = "add"))


#Retrieve configuration and operations names from column headers of each file
configurationTypes <- colnames(dddDataset)[1:7]
operations <- sort(colnames(dddDataset)[8:length(colnames(dddDataset))])

configurationTypes2 <- colnames(addDataset)[1:7]
operations3 <- sort(colnames(addDataset)[8:length(colnames(addDataset))])

#Reorder datsets by ordering columns alphabetically. Skip the following lines if datasets are already ordered
dddOperationDataset <- dddDataset[, sort(operations)]
addOperationDataset <- addDataset[, sort(operations3)]
#
dddConfigurationsDataSet <- dddDataset[, configurationTypes]
temp1 <-
  cbind(rep("ddd", nrow(dddConfigurationsDataSet)), dddConfigurationsDataSet)
colnames(temp1)[1] <- "ID"
colnames(temp1)[2] <- "Users"
loads1 <- temp1[, c("ID", "Users", "Metric")]
ddd <- cbind(loads1, dddOperationDataset)
#
addConfigurationsDataSet <- addDataset[, configurationTypes]
temp3 <-
  cbind(rep("add", nrow(addConfigurationsDataSet)), addConfigurationsDataSet)
colnames(temp3)[1] <- "ID"
colnames(temp3)[2] <- "Users"
loads3 <- temp3[, c("ID", "Users", "Metric")]
add <- cbind(loads3, addOperationDataset)

#Retrieve laods in natural order
myMax <- max(ddd$Users)
mySplitting <- unique(ddd$Users)
myOrderedSplitting <- mySplitting[order(mySplitting)]
#print(colnames(mono))

#RETRIEVE THE OPERATIONAL PROFILE
#From actual frequency values of loads
aggregatedValues <- data.frame()
aggregatedValues <-
  cbind(
    # c(10,    20,    40,    50,    60,    80,    100,   150,   200,   250,   300,   350),
    # c(0.010, 0.015, 0.023, 0.037, 0.045, 0.069, 0.138, 0.207, 0.239, 0.247, 0.155, 0.031)
    c(5, 10, 20, 40, 50, 60, 80, 100, 150, 200, 250, 300, 350),
    c(0.008, 0.010, 0.015, 0.023, 0.037, 0.045, 0.059, 0.124, 0.211, 0.198, 0.152, 0.107, 0.011)
    #c(5,     10,    20,    40,    50,    60,    80,    100,   150,   200),
    #c(0.008, 0.023, 0.037, 0.045, 0.069, 0.138, 0.207, 0.239, 0.247, 0.155)
  )

#Set the directory for the results
setwd("../../")
resultsDirectory <- paste(getwd(), "/Results/", sep = "")
if (!dir.exists("Results")) {
  dir.create("Results")
}
if (!dir.exists("Results/Plots")) {
  dir.create("Results/Plots")
}

setwd(scriptDirectory)
#Run all the functions to compute the relative and the cumulative domain metric
source("computeDM_FUNCTIONS.R")

#baseline data
# usedDataFile <- rbind(mono, role, cqrs)
usedDataFile <- rbind(ddd, add)
#mean of microservice requests
avg <- usedDataFile[usedDataFile$Metric == "Avg (sec)", -3]
#standard deviation of microservice requests
SD <- usedDataFile[usedDataFile$Metric == "SD (sec)", -3]
#This is the frequency of microservice requests
mixTemp <-
  usedDataFile[usedDataFile$Metric == "Mix % (take failure into account)", -3]

#COMPUTE THE THRESHOLD
noMicroServices <- length(operations)
# To use with computeThreshold.R. Threshold is derived from the mono dataset
dataBaseline <- ddd

par <- 5
threshold <- NULL
failingServices <- NULL
failures <- NULL
source("computeThreshold_train.R")

#COMPUTE THE FAILING MICROSERVICES
#threshold is the scalability requirement; avg is the response time of the MS; mixTemp is the frequency vector; computeRelativeMass requires to execute "computeDM_FUNCTIONS.R"
failures <-
  computeRelativeMass(threshold, avg, mixTemp, noMicroServices)

#total probability of non-failure per type of configuration mono/cqrs/role and load
relativeMass <- failures[[1]]

#micorservices that fail per type of configuration and load
temp_failingServices <- failures[[2]]
colnames(temp_failingServices) <-
  c("architectureType",
    "loadIntensity",
    "mix",
    "avg",
    "microservice")

if (length(temp_failingServices[, 1]) > 1) {
  failingServices <-
    temp_failingServices[order(temp_failingServices[, 1]),]
} else {
  failingServices <- temp_failingServices
}
setwd("../")
write.csv(
  failingServices,
  paste(
    "Results/",
    par,
    "_",
    strRem,
    "_failingMicroservice.csv",
    sep = ""
  ),
  row.names = F
)


#total probability of non-failure times probability of access of load per type of configuration and load
domainMetricList <-
  computeDomainMetrics(relativeMass, aggregatedValues)

#cumulative (over loads) probability of non-failure per type of configuration
domainMetric <- lapply(domainMetricList, function(x) {
  sum(x$absoluteMass)
})

#plotting polygons
print("Start plotting polygon")
type <- names(domainMetricList)
colnames(aggregatedValues) <- c("load intensity", "Domain metric")
myCol = c("blue", "darkgreen")
par(oma = c(0, 0, 0, 0))

png(paste("Results/Plots/TT-DM.png", sep = ""))
plot(
  aggregatedValues,
  xlim = c(-10, aggregatedValues[nrow(aggregatedValues), 1] + 10),
  pch = 19,
  pt.cex = 1,
  cex.axis = 1.3,
  ylim = c(0, max(aggregatedValues[, 2]) + 0.1),
  xaxt = "n",
  cex.lab = 1.5,
  bty = "n"
) +
  axis(
    1,
    at = c(8, aggregatedValues[-1,][, 1]),
    labels = c(5, aggregatedValues[-1,][, 1]),
    lwd.ticks = 1,
    cex.axis = 1.3
  )
#print all polygons of the given configurations
for (index in type) {
  i <- which(type == index)
  polygon(
    c(
      min(aggregatedValues[, 1]),
      t(domainMetricList[[index]]$Users),
      max(aggregatedValues[, 1])
    ),
    c(0, t(domainMetricList[[index]]$absoluteMass), 0),
    col = adjustcolor(myCol[i], alpha.f = 0.1),
    lty = 1,
    lwd = 0.7,
    border = myCol[i]
  )
  lines(
    domainMetricList[[index]][, c("Users", "absoluteMass")],
    type = "p",
    lwd = 0.7,
    pt.cex = 1.3,
    pch = 19,
    col = myCol[i]
  )
}
polygon(
  c(
    min(aggregatedValues[, 1]),
    aggregatedValues[, 1],
    max(aggregatedValues[, 1])
  ),
  c(0, aggregatedValues[, 2], 0),
  col = adjustcolor("white", alpha.f = 0.1),
  pch = 19,
  lty = 1,
  lwd = 0.7,
  border = "darkblue",
  cex = 1.3
)
#print legend with DM values
legendNames <- c()
architectures <- c("DDD", "ADD")
names(domainMetric) <- architectures
for (i in 1:length(names(domainMetric))) {
  legendNames[i] <-
    paste(names(domainMetric)[i], " DM: ", domainMetric[i], sep = "")
}
text(
  aggregatedValues,
  labels = round(aggregatedValues[1:nrow(aggregatedValues), 2], 3),
  pos = 3,
  col = "black",
  cex = 1.3
)
legend(
  200,
  0.255,
  legendNames,
  text.width = 2.3,
  col = myCol,
  lty = 1,
  box.lty = 0,
  lwd = 4,
  yjust = 0,
  cex = 1.3,
  seg.len = 0.8,
  inset = 0,
  y.intersp = 1.5
)
graphics.off()
print("End plotting polygon")
# }

setwd(scriptDirectory)
#CREATE SPIDERS, RIDGE PLOTS
source("NewSpiders_train.R")


```


